import {
  __commonJS,
  __toESM
} from "./chunk-CEQRFMJQ.js";

// browser-external:module
var require_module = __commonJS({
  "browser-external:module"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "module" has been externalized for browser compatibility. Cannot access "module.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/windicss/helpers/index.mjs
var import_module = __toESM(require_module(), 1);
var import_path = __toESM(require_path(), 1);
function windi(strings) {
  var values = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    values[_i - 1] = arguments[_i];
  }
  return strings.reduce(function(query, queryPart, i) {
    var valueExists = i < values.length;
    var text = query + queryPart;
    return valueExists ? text + values[i] : text;
  }, "");
}
var lib = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addHook = addHook;
  var _module = _interopRequireDefault(import_module.default);
  var _path = _interopRequireDefault(import_path.default);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  const nodeModulesRegex = /^(?:.*[\\/])?node_modules(?:[\\/].*)?$/;
  const Module = module.constructor.length > 1 ? module.constructor : _module.default;
  const HOOK_RETURNED_NOTHING_ERROR_MESSAGE = "[Pirates] A hook returned a non-string, or nothing at all! This is a violation of intergalactic law!\n--------------------\nIf you have no idea what this means or what Pirates is, let me explain: Pirates is a module that makes is easy to implement require hooks. One of the require hooks you're using uses it. One of these require hooks didn't return anything from it's handler, so we don't know what to do. You might want to debug this.";
  function shouldCompile(filename, exts, matcher, ignoreNodeModules) {
    if (typeof filename !== "string") {
      return false;
    }
    if (exts.indexOf(_path.default.extname(filename)) === -1) {
      return false;
    }
    const resolvedFilename = _path.default.resolve(filename);
    if (ignoreNodeModules && nodeModulesRegex.test(resolvedFilename)) {
      return false;
    }
    if (matcher && typeof matcher === "function") {
      return !!matcher(resolvedFilename);
    }
    return true;
  }
  function addHook(hook, opts = {}) {
    let reverted = false;
    const loaders = [];
    const oldLoaders = [];
    let exts;
    const originalJSLoader = Module._extensions[".js"];
    const matcher = opts.matcher || null;
    const ignoreNodeModules = opts.ignoreNodeModules !== false;
    exts = opts.extensions || opts.exts || opts.extension || opts.ext || [".js"];
    if (!Array.isArray(exts)) {
      exts = [exts];
    }
    exts.forEach((ext) => {
      if (typeof ext !== "string") {
        throw new TypeError(`Invalid Extension: ${ext}`);
      }
      const oldLoader = Module._extensions[ext] || originalJSLoader;
      oldLoaders[ext] = Module._extensions[ext];
      loaders[ext] = Module._extensions[ext] = function newLoader(mod, filename) {
        let compile;
        if (!reverted) {
          if (shouldCompile(filename, exts, matcher, ignoreNodeModules)) {
            compile = mod._compile;
            mod._compile = function _compile(code) {
              mod._compile = compile;
              const newCode = hook(code, filename);
              if (typeof newCode !== "string") {
                throw new Error(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);
              }
              return mod._compile(newCode, filename);
            };
          }
        }
        oldLoader(mod, filename);
      };
    });
    return function revert() {
      if (reverted)
        return;
      reverted = true;
      exts.forEach((ext) => {
        if (Module._extensions[ext] === loaders[ext]) {
          Module._extensions[ext] = oldLoaders[ext];
        }
      });
    };
  }
})(lib, lib.exports);
function convert(code) {
  var map = {
    "@tailwindcss\\/typography": "windicss/plugin/typography",
    "@tailwindcss\\/forms": "windicss/plugin/forms",
    "@tailwindcss\\/aspect-ratio": "windicss/plugin/aspect-ratio",
    "@tailwindcss\\/line-clamp": "windicss/plugin/line-clamp",
    "tailwindcss\\/plugin": "windicss/plugin",
    "tailwindcss\\/colors": "windicss/colors",
    "tailwindcss\\/resolveConfig": "windicss/resolveConfig",
    "tailwindcss\\/defaultConfig": "windicss/defaultConfig",
    "tailwindcss\\/defaultTheme": "windicss/defaultTheme"
  };
  for (var _i = 0, _a = Object.entries(map); _i < _a.length; _i++) {
    var _b = _a[_i], key = _b[0], value = _b[1];
    code = code.replace(new RegExp(key, "g"), value);
  }
  return code;
}
function transform(path) {
  var require2 = (0, import_module.createRequire)(import.meta.url);
  var matcher = function(filename) {
    return !/\/windicss\//.test(filename);
  };
  var revert = lib.exports.addHook(function(code) {
    return convert(code);
  }, { exts: [".js"], matcher, ignoreNodeModules: false });
  var mod = require2(path);
  revert();
  return mod;
}
function defineConfig(config) {
  return config;
}
export {
  convert,
  defineConfig,
  transform,
  windi
};
//# sourceMappingURL=windicss_helpers.js.map
